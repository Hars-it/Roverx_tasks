The interrupt is a signal emitted by hardware or software when a process or an event needs immediate attention. It alerts the processor to a high-priority process requiring interruption of the current working process. In I/O devices one of the bus control lines is dedicated for this purpose and is called the Interrupt Service Routine (ISR).
When a device raises an interrupt at let’s say process i, the processor first completes the execution of instruction i. Then it loads the Program Counter (PC) with the address of the first instruction of the ISR. Before loading the Program Counter with the address, the address of the interrupted instruction is moved to a temporary location. Therefore, after handling the interrupt the processor can continue with process i+1.

## Triggering Methods

Every interrupt signal input is intended to be activated by a certain signal edge (level change) or a logic signal level. Level-sensitive inputs make constant requests for processor attention as long as they are treated with a specific logic level (high or low). Edge-sensitive inputs are responsive to signal edges; a service request will latch on to a specific (rising or falling) edge. When the interrupt handler runs, the CPU resets the latch.

- Level-Trigger:**** The interrupt signal must be held at its specific active logic level (high or low) to request a level-triggered interrupt. A level-triggered interrupt is triggered when a device drives the signal to the active level and maintains it there. When the CPU instructs it to do so, usually after the device has been serviced, it denies the signal.
- Edge-Trigger: An interrupt that is caused by a level change on the interrupt line—either a rising or lowering edge—is known as an edge-triggered interrupt (low to high). A pulse is driven onto the line and released to its inactive state by a device that wishes to indicate an interrupt. It can be necessary to use specialized hardware to detect the pulse if polled I/O is unable to pick it up due to its short duration.


In its basic form, an interrupt works like this:

- A program is running.
- An interrupt occurs.
- The program is paused, and its data is put aside so that it can resume later.
- The code related to the interrupt is run.
- When the interrupt code has finished, the program resumes where it left off.

ARDUINO INTERRUPTS
The Arduino Uno supports three types of interrupts:

- **Hardware Interrupts** – External interrupt signals on specific pins.
- **Pin Change Interrupts** – External interrupts on any pin, grouped into ports.
- **Timer Interrupts** – Internal timer-generated interrupts, manipulated in software


![[Pasted image 20240501102024.png]]
An Interrupt Service Routine, or ISR, is essentially a function. However, unlike regular Arduino functions, you can’t pass parameters to it, nor get any value returned from it.

![[Pasted image 20240503222148.png]]

Hardware Interrupts

Hardware interrupts are external interrupts, and on most Arduino models are limited to specific pins.  These pins are configured as inputs and can trigger hardware interrupts by manipulating their logic state.
Hardware Interrupt is caused by some hardware device such as request to start an I/O, a hardware failure or something similar. Hardware interrupts were introduced as a way to avoid wasting the processor’s valuable time in polling loops, waiting for external events. 

For example, when an I/O operation is completed such as reading some data into the computer from a tape drive.

- An interrupt generated by a mouse when a button is clicked
- An interrupt generated by a network card when data is received
- An interrupt generated by a disk drive when a read or write operation is completed

 Software Interrupt : Software Interrupt is invoked by the use of INT instruction. This event immediately stops execution of the program and passes execution over to the INT handler. The INT handler is usually a part of the operating system and determines the action to be taken. It occurs when an application program terminates or requests certain services from the operating system. 

For example, output to the screen, execute file etc. 

- A system call to read or write data to a file
- A division by zero exception
- A page fault exception


![[Pasted image 20240501103318.png]]
To work with interrupts
- Write a function to use as your Interrupt Service Routine.
- Attach the function to the specific interrupt you want to use, and specify how to trigger it.
- Pin 2 – Interrupt vector 0
- **Pin 3** – Interrupt vector 1.

attachInterrupt()
![[Pasted image 20240501103619.png]]
- **Interrupt Vector** – the interrupt that you wish to use. Note that this is the internal Interrupt Vector number and NOT the pin number.
- **ISR** – The name of the Interrupt Service Routine function that you are gluing to the interrupt.
- **Mode** – How you want to trigger the interrupt.

For Mode, there are four selections:

- **RISING** – Triggers when an input goes from LOW to HIGH.
- **FALLING** – Triggers when an input goes from HIGH to LOW.
- **LOW** – Triggered when the input stays LOW.
- **CHANGE** – Triggers whenever the input changes state from HIGH to LOW or LOW to HIGH.


digitalPinToInterrupt()
The function’s name is also its description, it accepts a pin number and returns the Interrupt Vector number.
You can use _digitalPinToInterrupt_ directly within the attachInterrupt function.

attachInterrupt(digitalPinToInterrupt(pin),ISR,Mode)


## Pin Change Interrupts

Pin Change Interrupts are another form of a hardware interrupt. Unlike the interrupts we have just used, they are not restricted to specific pins, all the pins can be used for Pin Change Interrupts.

### Pin Change Ports

Almost every pin on the ATmega328 chip that the Arduino Uno (and other boards) are based upon can support 24 Pin Change Interrupts.  That includes the two pins used for the 16MHz crystal oscillator.
![[Pasted image 20240503223705.png]]
![[Pasted image 20240501104757.png]]

On the Arduino Uno, 20 pins are available for Pin Change Interrupts, and they are divided into three ports.
Pins 8 through 13 are on Port B.

![[Pasted image 20240501104826.png]]
Pins A0 to A5 are on Port C.

![[Pasted image 20240501105131.png]]
Pins 0 to 7 are on Port D.

In order to use Pin Change Interrupts, you’ll need to do the following:

- Determine which pin(s) that you want to use.  This will also tell you which port(s) you’ll need to use.
- Enable the port(s) that you need.
- Enable the pin(s) within that port that must be enabled for interrupts.
- Edit the appropriate Interrupt Service Routine(s). If you are using more than one pin on the same port, then the ISR will need to be able to determine which pin caused the interrupt.

#### Select the Port

The first step is to enable the appropriate port, which you’ll determine based on the pin number. To enable the port, you will use the _Pin Change Interrupt Control Register_ or PCICR.

![[Pasted image 20240501105952.png]]
The PCICR has three bits of interest, Bit 0, Bit 1, and Bit 2. Each bit is associated with one of the ports, and setting it to 1 will enable the port.

#### Enable/Disable the Pins on the Port

After enabling the port, you’ll need to enable the pin(s) that you want to use for Pin Change Interrupts.  You do that by modifying the _Pin Change Mask_ for your selected port.
![[Pasted image 20240501110221.png]]
There are three Pin Change Masks, and each one can enable or disable 8 pins. To enable a pin, you write a “1” to it.

Interrupt Service Routine
![[Pasted image 20240501110625.png]]


## Timer Interrupts

Timer interrupts don’t use external signals. Instead, these interrupts are generated in software, and their timing is based upon the Arduino Uno’s 16 MHz clock oscillator.

![[Pasted image 20240501110932.png]]

These timers are not the same, as Timer1 is a 16-bit timer, whereas the other two timers are just 8-bit timers. The number of bits determines the maximum number that the timer can count to, 256 for the 8-bit timers and 65,536 for the 16-bit one.

### Dividing the Clock Frequency

The Timers are clocked by the 16 MHz oscillator which is internal to the ATmega328. 

![[Pasted image 20240503214335.png]]

Every cycle of the clock is a timer “tick”, so at 16 MHz a “tick” would be a period of 62.5 nanoseconds.  This is too short for practical applications.
To slow down the clock signal, the ATmega328 has a “Prescaler”, essentially a divider for the clock frequency. The Prescaler can divide the clock down to a more manageable lower frequency, you can select from a number of common divisions to create pulses as long as 64us.

![[Pasted image 20240503214430.png]]

Each timer has three Clock Select Bits, and the value of these bits can determine the Prescaler settings, as well as the timing source.  You can also stop the clock entirely by setting all the Clock Select Bits to zero.

![[Pasted image 20240503214519.png]]
Timer0, an 8-bit Timer, uses bits CS01, CS02, and CS03
![[Pasted image 20240503215036.png]]
Timer1, the 16-bit timer, uses bits CS10, CS11, and CS12.
![[Pasted image 20240503215147.png]]
Timer2, another 8-bit timer, uses bits CS20, CS21, and CS22.

![[Pasted image 20240503225940.png]]
